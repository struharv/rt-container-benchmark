/*  Copyright (c) 2013, Robert Wang, email: robertwgh (at) gmail.com
    All rights reserved. https://github.com/robertwgh/ezSIFT

    Description: Detect keypoints and extract descriptors from an input image.

    Revision history:
        September 15th, 2013: initial version.
        July 2nd, 2018: code refactor.
*/
#include "ezsift.h"
#include "malloc.h"
#include <iostream>
#include <list>
#include <unistd.h>
#include <malloc.h>
#include "wrapper.h"
#define QUEUE_NAME "/performance_counters"
int perf_array[14];
mqd_t mq;
char * perf_strings[14];
static inline long long unsigned time_ns(struct timespec* const ts) {
  /* We use monotonic to avoid any leap-problems generated by NTP. */
  if (clock_gettime(CLOCK_MONOTONIC, ts)) {
    exit(1);
  }
  return ((long long unsigned) ts->tv_sec) * 1000000000LLU
    + (long long unsigned) ts->tv_nsec;
}


int stick_this_thread_to_core(int core_id) {
   int num_cores = sysconf(_SC_NPROCESSORS_ONLN);
   if (core_id < 0 || core_id >= num_cores)
   {
	printf("Core out of index");
	return 0;
   }

   cpu_set_t cpuset;
   CPU_ZERO(&cpuset);
   CPU_SET(core_id, &cpuset);

   pthread_t current_thread = pthread_self();    
   return pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset);
}

#define USE_FIX_FILENAME 0
int main(int argc, char *argv[])
{

#if USE_FIX_FILENAME
    char *file1 = "img1.pgm";
#else
    if (argc < 2) {
        std::cerr
            << "Please input an input image name.\nUsage: feature_extract img"
            << std::endl;
        return -1;
    }
    if (mallopt(M_MMAP_THRESHOLD, 0) != 1) {
                   fprintf(stderr, "mallopt() failed");
                   exit(EXIT_FAILURE);
            }
    char file1[255];
    memcpy(file1, argv[1], sizeof(char) * strlen(argv[1]));
    file1[strlen(argv[1])] = 0;
    planet_type message;
    message.pid = 0;
    //printf("Monitor pid is:%d", message.pid);
    message.perf_counter = 0;
    //snprintf(message.performance, sizeof(message.performance), "%d", pixels_traversed);
    message.target_performance = 0;
    message.done = 0;
    
#endif
    int number = 0;
    int monitor_pid = 0;
    int perf_id = 0;
    struct timespec ts;
    long long unsigned timestamp;
    long long unsigned timestamp_after;
    timestamp = time_ns(&ts);
    double exec = 0.0;
    double elapsed = 0.0;
    //init_args();
    monitor_pid = getpid();
    printf("pid is %d\n", monitor_pid);
    int affinity = atoi(argv[2]);
    int tests = atoi(argv[3]);
    ezsift::Image<unsigned char> image;
    MQconnect(&mq, QUEUE_NAME);
    message.pid = monitor_pid;
    MQwrite(&mq, &message);
    //std::cout << "Image size: " << image.w << "x" << image.h << std::endl;

    bool bExtractDescriptor = true;
    //stick_this_thread_to_core(affinity);
	

    // Perform SIFT computation on CPU.


    
    
    
    //std::cout << "Start SIFT detection ..." << std::endl;
    int count = 0;
    while (count < tests)
    {
    clock_t start = clock();
	if (ezsift::read_pgm(file1, image.data, image.w, image.h) != 0) {
        std::cerr << "Failed to open input image." << std::endl;
        return -1;
    }
    // Double the original image as the first octive.
    ezsift::double_original_image(true);
    timestamp = time_ns(&ts);
    std::list<ezsift::SiftKeypoint> kpt_list;
    ezsift::sift_cpu(image, kpt_list, bExtractDescriptor);

    	timestamp_after = time_ns(&ts);
	
    	clock_t stop = clock();
    	elapsed = (double)(timestamp_after - timestamp) * 0.000001;
	printf("ms: %f\n", elapsed);
	count++;
	message.done = 1;
	MQwrite(&mq, &message);
    // Generate output image with keypoints drawing
    //char filename[255];
    //sprintf(filename, "%s_sift_output.ppm", file1);
    //ezsift::draw_keypoints_to_ppm_file(filename, image, kpt_list);

    // Generate keypoints list
    //sprintf(filename, "%s_sift_key.key", file1);
    //ezsift::export_kpt_list_to_file(filename, kpt_list, bExtractDescriptor);

    //std::cout << "\nTotal keypoints number: \t\t"
    //          << static_cast<unsigned int>(kpt_list.size()) << std::endl;
	}

    return 0;
}
